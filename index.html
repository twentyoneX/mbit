<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mBIT v5 (Final Fix)</title>
    <script src="https://unpkg.com/nostr-tools@1.17.0/lib/nostr.bundle.js"></script>
    <style>
        :root { --bg: #000; --txt: #fff; --acc: #00FF41; --brd: #333; --pnl: #111; font-family: monospace; }
        body { background: var(--bg); color: var(--txt); margin: 0; padding: 10px; padding-bottom: 80px; max-width: 600px; margin: 0 auto; }
        
        /* HEADER & NAV */
        header { text-align: center; border-bottom: 1px solid var(--brd); padding: 10px; margin-bottom: 20px; }
        .nav { display: flex; justify-content: center; gap: 15px; user-select: none; margin-top: 10px; }
        .nav span { cursor: pointer; opacity: 0.7; }
        .nav span:hover { opacity: 1; color: var(--acc); text-decoration: underline; }
        
        /* PANELS */
        .panel { display: none; }
        .panel.active { display: block; }
        
        /* POSTS */
        .post { border: 1px solid var(--brd); padding: 15px; margin-bottom: 15px; background: #050505; word-wrap: break-word; }
        .post-meta { color: #888; font-size: 0.8em; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .post-content { font-size: 1em; line-height: 1.4; white-space: pre-wrap; }
        .post-actions { margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333; display: flex; gap: 10px; }
        
        /* THREAD SPECIALS */
        .thread-ancestor { border-left: 2px dotted #555; padding-left: 15px; margin-bottom: 10px; opacity: 0.8; font-size: 0.9em; }
        .thread-main { border: 2px solid var(--acc); background: #081008; }
        .thread-reply { margin-left: 10px; border-left: 2px solid #333; }
        
        /* NOTIFICATIONS */
        .notif { padding: 15px; border-bottom: 1px solid var(--brd); cursor: pointer; display: flex; gap: 10px; }
        .notif:hover { background: #111; }

        /* BUTTONS & INPUTS */
        button { background: var(--txt); color: #000; border: none; padding: 8px 15px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
        button:hover { opacity: 0.8; }
        button.sec { background: #333; color: #fff; border: 1px solid #555; }
        input, textarea { background: #000; color: #fff; border: 1px solid #333; padding: 10px; width: 100%; box-sizing: border-box; margin-bottom: 10px; }

        /* FOOTER & FAB */
        .footer { position: fixed; bottom: 0; left: 0; width: 100%; background: #000; border-top: 1px solid var(--brd); display: flex; justify-content: center; gap: 20px; padding: 15px; z-index: 100; }
        .fab { position: fixed; bottom: 80px; right: 20px; width: 50px; height: 50px; background: var(--acc); color: #000; border-radius: 50%; font-size: 30px; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 100; }
        
        /* MODAL */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 200; }
        .modal-content { background: #111; border: 1px solid var(--acc); padding: 20px; width: 90%; max-width: 500px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<header>
    <h1>mBIT</h1>
    <div class="nav">
        <span onclick="route('feed')">#FEED</span>
        <span onclick="route('notifs')">#NOTIFS</span>
        <span onclick="route('profile')">#PROFILE</span>
        <span onclick="route('settings')">#SETTINGS</span>
    </div>
</header>

<!-- FEED PANEL -->
<div id="feed-panel" class="panel active">
    <div id="feed-list">Loading global feed...</div>
</div>

<!-- THREAD PANEL -->
<div id="thread-panel" class="panel">
    <button class="sec" onclick="route('feed')">&lt; BACK TO FEED</button>
    <h3 style="border-bottom: 1px dashed #333; padding: 10px 0;">>> THREAD CONTEXT</h3>
    
    <!-- Area for Parent Note -->
    <div id="thread-ancestor-container"></div>
    
    <!-- Area for Main Note -->
    <div id="thread-main-container"></div>
    
    <div style="margin: 20px 0; border-bottom: 1px dashed #333;">Replies:</div>
    
    <!-- Area for Replies -->
    <div id="thread-replies-container">Loading comments...</div>
</div>

<!-- NOTIFICATIONS PANEL -->
<div id="notifs-panel" class="panel">
    <h3>>> NOTIFICATIONS</h3>
    <div id="notif-list">Please login to see notifications.</div>
</div>

<!-- SETTINGS / LOGIN -->
<div id="settings-panel" class="panel">
    <h3>>> LOGIN & SETTINGS</h3>
    <input id="pk-input" placeholder="Enter nsec key...">
    <button onclick="loginKey()">LOGIN WITH KEY</button>
    <button class="sec" onclick="loginExt()" style="margin-top:5px;">USE EXTENSION</button>
    <br><br>
    <button class="sec" onclick="logout()">LOGOUT</button>
    <div id="user-status" style="margin-top:10px; opacity:0.7;"></div>
</div>

<!-- PROFILE -->
<div id="profile-panel" class="panel">
    <h3>>> MY PROFILE</h3>
    <div id="profile-data"></div>
</div>

<div class="fab" onclick="openComposer()">+</div>

<!-- COMPOSER MODAL -->
<div id="composer" class="modal">
    <div class="modal-content">
        <div id="reply-context-text" style="margin-bottom:10px; font-size:0.8em; opacity:0.7;"></div>
        <textarea id="compose-text" rows="5" placeholder="Type something..."></textarea>
        <div style="display:flex; gap:10px;">
            <button class="sec" style="flex:1" onclick="closeComposer()">CANCEL</button>
            <button style="flex:1" onclick="publishNote()">SEND</button>
        </div>
    </div>
</div>

<div class="footer">
    <span onclick="route('feed')">#HOME</span>
    <span onclick="route('notifs')">#NOTIFS</span>
    <span onclick="route('settings')">#SETTINGS</span>
</div>

<script>
// --- CONFIGURATION ---
const RELAYS = [
    'wss://relay.damus.io',
    'wss://relay.primal.net',
    'wss://nos.lol',
    'wss://relay.nostr.band' 
];

// --- GLOBAL STATE ---
const pool = {};
const eventsMap = new Map(); // Stores all events by ID
const profilesMap = {};      // Stores profiles by pubkey
let myPub = localStorage.getItem('mbit_pub');
let myPriv = localStorage.getItem('mbit_priv');
let currentThreadId = null;
let replyToEvent = null;

// --- INITIALIZATION ---
function init() {
    if(myPub) document.getElementById('user-status').innerText = "Logged in as: " + myPub.substring(0,8) + "...";
    
    // Connect to Relays
    RELAYS.forEach(url => {
        try {
            const ws = new WebSocket(url);
            pool[url] = ws;
            ws.onopen = () => {
                console.log("Connected to", url);
                // Subscribe to Global Feed
                sub(ws, "feed", { kinds: [1], limit: 25 });
                
                // Subscribe to Notifications (if logged in)
                if(myPub) {
                    sub(ws, "notifs", { '#p': [myPub], kinds: [1, 6, 7, 9735], limit: 50 });
                }
            };
            ws.onmessage = (msg) => handleMessage(msg);
        } catch(e) { console.error(e); }
    });
}

function sub(ws, id, filter) {
    ws.send(JSON.stringify(["REQ", id, filter]));
}

// --- EVENT HANDLER ---
function handleMessage(msg) {
    const data = JSON.parse(msg.data);
    if (data[0] !== 'EVENT') return;

    const subId = data[1];
    const ev = data[2];

    // 1. Store Event
    if (!eventsMap.has(ev.id)) {
        eventsMap.set(ev.id, ev);
        
        // 2. Fetch Profile if unknown
        if (!profilesMap[ev.pubkey]) {
            profilesMap[ev.pubkey] = {}; // Placeholder to stop spamming reqs
            fetchProfile(ev.pubkey);
        }

        // 3. Update UI based on what we are looking at
        if (subId === 'feed') updateFeedUI();
        if (subId === 'notifs') updateNotifsUI();
        
        // THREAD HANDLING
        if (subId.startsWith('thread_')) {
            // If we are viewing a thread, re-render to show new data
            if (!document.getElementById('thread-panel').classList.contains('hidden')) {
                renderThread(currentThreadId);
            }
            
            // If this event has a parent we don't have, go get it!
            const parentId = getParentId(ev);
            if (parentId && !eventsMap.has(parentId)) {
                fetchSingleNote(parentId);
            }
        }

        // PROFILE METADATA
        if (ev.kind === 0) {
            try { profilesMap[ev.pubkey] = JSON.parse(ev.content); updateFeedUI(); } catch(e){}
        }
    }
}

// --- NAVIGATION ---
function route(page) {
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    document.getElementById(page + '-panel').classList.add('active');
    
    if (page === 'feed') updateFeedUI();
    if (page === 'notifs') updateNotifsUI();
}

// --- THREAD ENGINE (THE CRITICAL PART) ---
function openThread(id) {
    console.log("OPENING THREAD FOR ID:", id);
    currentThreadId = id;
    route('thread');
    
    // Clear previous view
    document.getElementById('thread-ancestor-container').innerHTML = '';
    document.getElementById('thread-main-container').innerHTML = 'Loading note...';
    document.getElementById('thread-replies-container').innerHTML = 'Loading comments...';

    // 1. Ask ALL relays for this specific note
    fetchSingleNote(id);

    // 2. Ask ALL relays for replies to this note
    Object.values(pool).forEach(ws => {
        if(ws.readyState === 1) {
            // Get replies aggressively
            sub(ws, "thread_replies_" + id, { kinds: [1], '#e': [id], limit: 100 });
        }
    });

    // 3. Attempt to render immediately if in cache
    renderThread(id);
}

function getParentId(ev) {
    // Finds the ID of the note this event is replying to
    const eTags = ev.tags.filter(t => t[0] === 'e');
    if (eTags.length === 0) return null;
    
    // Check for "reply" marker
    const replyTag = eTags.find(t => t[3] === 'reply');
    if (replyTag) return replyTag[1];

    // Check for "root" marker
    const rootTag = eTags.find(t => t[3] === 'root');
    if (rootTag) return rootTag[1]; // Fallback to root if no reply marker

    // Fallback: Last 'e' tag is usually the immediate parent (NIP-10)
    return eTags[eTags.length - 1][1];
}

function fetchSingleNote(id) {
    Object.values(pool).forEach(ws => {
        if(ws.readyState === 1) {
            sub(ws, "thread_target_" + id, { kinds: [1], ids: [id] });
        }
    });
}

function renderThread(id) {
    if (id !== currentThreadId) return; // Prevent race conditions

    const mainNote = eventsMap.get(id);
    
    if (!mainNote) {
        document.getElementById('thread-main-container').innerHTML = "Fetching from relays...";
        return;
    }

    // 1. Render Main Note
    document.getElementById('thread-main-container').innerHTML = renderCard(mainNote, "thread-main");

    // 2. Check for Parent (Ancestor)
    const parentId = getParentId(mainNote);
    if (parentId) {
        const parentNote = eventsMap.get(parentId);
        if (parentNote) {
            document.getElementById('thread-ancestor-container').innerHTML = `
                <div style="opacity:0.6; font-size:0.8em; margin-bottom:5px;">Replying to:</div>
                ${renderCard(parentNote, "thread-ancestor")}
            `;
        } else {
            // Parent ID exists but we don't have the content yet
            document.getElementById('thread-ancestor-container').innerHTML = `<button class="sec" onclick="fetchSingleNote('${parentId}')">Load Parent Note</button>`;
            fetchSingleNote(parentId); // Auto fetch
        }
    } else {
        document.getElementById('thread-ancestor-container').innerHTML = '';
    }

    // 3. Render Replies
    // Filter all known events for ones that tag this ID
    const replies = Array.from(eventsMap.values()).filter(ev => {
        if (ev.kind !== 1) return false;
        const pId = getParentId(ev);
        // It's a reply if its parent is the current thread ID
        return pId === id; 
    }).sort((a,b) => a.created_at - b.created_at);

    if (replies.length > 0) {
        document.getElementById('thread-replies-container').innerHTML = replies.map(ev => renderCard(ev, "thread-reply")).join('');
    } else {
        document.getElementById('thread-replies-container').innerHTML = "No replies found (yet).";
    }
}

// --- UI RENDERING ---
function renderCard(ev, extraClass = "") {
    const p = profilesMap[ev.pubkey] || {};
    const name = p.name || p.display_name || ev.pubkey.substring(0,8);
    const pic = p.picture || '';
    
    return `
    <div class="post ${extraClass}">
        <div class="post-meta" onclick="openThread('${ev.id}')">
            <div style="display:flex;align-items:center;gap:10px;">
                ${pic ? `<img src="${pic}" class="avatar">` : `<div class="avatar"></div>`}
                <b style="color:#fff">${name}</b>
            </div>
            <span>${new Date(ev.created_at * 1000).toLocaleTimeString()}</span>
        </div>
        <div class="post-content" onclick="openThread('${ev.id}')">${ev.content}</div>
        <div class="post-actions">
            <button class="sec" onclick="prepReply('${ev.id}')">REPLY</button>
            <button class="sec" onclick="sendLike('${ev.id}', '${ev.pubkey}')">LIKE</button>
        </div>
    </div>`;
}

function updateFeedUI() {
    const list = Array.from(eventsMap.values())
        .filter(e => e.kind === 1) // Only text notes
        .sort((a,b) => b.created_at - a.created_at) // Newest first
        .slice(0, 50); // Limit to 50
        
    document.getElementById('feed-list').innerHTML = list.map(ev => renderCard(ev)).join('');
}

function updateNotifsUI() {
    if(!myPub) return;
    const list = Array.from(eventsMap.values())
        .filter(e => e.tags.some(t => t[0] === 'p' && t[1] === myPub)) // Tags me
        .filter(e => e.kind === 1 || e.kind === 6 || e.kind === 7 || e.kind === 9735) // Replies, Reposts, Likes, Zaps
        .sort((a,b) => b.created_at - a.created_at)
        .slice(0, 50);
        
    document.getElementById('notif-list').innerHTML = list.map(ev => {
        const p = profilesMap[ev.pubkey] || {};
        const name = p.name || ev.pubkey.substring(0,6);
        
        // TARGET LOGIC: Find what they are replying to/liking
        let targetId = null;
        const eTag = ev.tags.find(t => t[0] === 'e');
        if (eTag) targetId = eTag[1];

        // Ensure clicking goes to the TARGET note, not the like event itself
        const clickAction = targetId ? `onclick="openThread('${targetId}')"` : '';

        if(ev.kind === 7) return `<div class="notif" ${clickAction}><span style="color:red">‚ù§</span> <b>${name}</b> liked your note.</div>`;
        if(ev.kind === 6) return `<div class="notif" ${clickAction}><span style="color:green">‚Üª</span> <b>${name}</b> reposted your note.</div>`;
        if(ev.kind === 9735) return `<div class="notif" ${clickAction}><span style="color:gold">‚ö°</span> <b>${name}</b> zapped you!</div>`;
        if(ev.kind === 1) return `<div class="notif" onclick="openThread('${ev.id}')"><span>üí¨</span> <div><b>${name}</b> replied: <br> ${ev.content}</div></div>`;
    }).join('');
}

function fetchProfile(pubkey) {
    Object.values(pool).forEach(ws => {
        if(ws.readyState === 1) {
            sub(ws, "meta_" + pubkey.substring(0,8), { kinds:[0], authors:[pubkey], limit:1 });
        }
    });
}

// --- COMPOSER ---
function openComposer() { document.getElementById('composer').style.display = 'flex'; }
function closeComposer() { document.getElementById('composer').style.display = 'none'; replyToEvent = null; document.getElementById('reply-context-text').innerText = ''; }

function prepReply(id) {
    replyToEvent = id;
    document.getElementById('reply-context-text').innerText = "Replying to: " + id.substring(0,10) + "...";
    openComposer();
}

async function publishNote() {
    const text = document.getElementById('compose-text').value;
    if(!text) return;
    
    const ev = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [],
        content: text,
        pubkey: myPub
    };

    if (replyToEvent) {
        ev.tags.push(['e', replyToEvent, '', 'reply']);
    }

    // Signing
    try {
        if (window.nostr) {
            const signed = await window.nostr.signEvent(ev);
            ev.id = signed.id; 
            ev.sig = signed.sig;
        } else if (myPriv) {
            ev.id = window.NostrTools.getEventHash(ev);
            ev.sig = window.NostrTools.signEvent(ev, myPriv);
        } else {
            alert("No Login Found"); return;
        }
        
        Object.values(pool).forEach(ws => {
            ws.send(JSON.stringify(["EVENT", ev]));
        });
        closeComposer();
        document.getElementById('compose-text').value = '';
    } catch(err) { alert("Error: " + err); }
}

async function sendLike(id, pubkey) {
    if(!myPub) return alert("Login first");
    const ev = { kind: 7, content: "+", tags: [['e', id], ['p', pubkey]], created_at: Math.floor(Date.now()/1000), pubkey: myPub };
    // Simplified signing for brevity
    if(window.nostr) { const s = await window.nostr.signEvent(ev); Object.values(pool).forEach(w => w.send(JSON.stringify(["EVENT", s]))); alert("Liked!"); }
}

// --- LOGIN ---
async function loginExt() {
    if(!window.nostr) return alert("No Extension");
    myPub = await window.nostr.getPublicKey();
    localStorage.setItem('mbit_pub', myPub);
    location.reload();
}
function loginKey() {
    const k = document.getElementById('pk-input').value;
    try {
        const { data } = window.NostrTools.nip19.decode(k);
        myPriv = data;
        myPub = window.NostrTools.getPublicKey(myPriv);
        localStorage.setItem('mbit_priv', myPriv);
        localStorage.setItem('mbit_pub', myPub);
        location.reload();
    } catch(e) { alert("Invalid Key"); }
}
function logout() { localStorage.clear(); location.reload(); }

// --- START ---
init();

</script>
</body>
</html>
